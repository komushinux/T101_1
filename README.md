### T101_1

**Описание структуры:**

`neg_or_pos_rules` - Функция разделения правил на 3 секции: *'and'*, *'or'* или *'not'*. Происходит за счет соответствующих ключей в каждом правиле. Возвращает 3 списка правил.

`controversy_ab_not_ab` - Функция разрешения противоречий типа *'A -> B & not(A) -> B'*. При совпадении условных и результирующих частей удаляются оба правила.

`controversy_not_a_b_not_b_a` - Функция разрешения противоречий типа *'not(A) -> B & not(B) -> A'*. При совпадении условной части первого, результирующей части второго правила и наоборот оба правила удаляются.

`check_...` - Функции сопоставления правил и фактов, получение новых фактов.

`main` - Главная функция, выдающая конечный результат.
<br/><br/>

**Описание функции check_or:**
- Параметры:
  + or_rules(list) - список всех or-правил
  + rang(int) - текущая вложенность (далее ранг)
  + res(list) - список, индексы которого численно равны фактам бз, значения: 1 или *None* в зависимости от существования факта 
  + or_mass(list) - список словарей, где ключи - ранги, значения - новые факты
  + max_rang(int) - максимальный ранг<br/><br/>

- Возвращает:
  + max_rang(int)<br/><br/>

- Алгоритм:
  + Вход в цикл, проходящий по всем or-правилам
  + Инициализация списка `buf` = списку фактов из правила на данной итерации
  + Если ранг = 1, то запускается цикл по `buf`, в котором:
    + Проверяется наличие текущего элемента условной части в списке фактов бз
    + При совпадении: `max_rang` = 2 (вложенность увеличилась на 1), добавление в `or_mass` словаря `{max_rang : новый факт из правила}`, добавление факта в `res`, выход из цикла 
  + Иначе цикл по `or_mass`, где лежат словари типа {ранг: добавленный факт}:
    + Проверка на соответствие текущего ранга ключу словаря и на отсутствие факта текущего правила в `res` (смысла повторно добавлять нет)
    + В случае успешной проверки, если значение текущего словаря из `or_mass` есть `buf`, максимальный ранг увеличивается на 1, массив `or_mass` пополняется, в `res` добавляется новый флаг 
  + `return max_rang` 
<br/><br/>


**Описание функции check_and:**
- Параметры:
  + and_rules(list) - список всех and-правил
  + rang(int) - текущая вложенность (далее ранг)
  + res(list) - список, индексы которого численно равны фактам бз, значения: 1 или *None* в зависимости от существования факта 
  + and_mass(list) - список словарей, где ключи - ранги, значения - новые факты
  + max_rang(int) - максимальный ранг<br/><br/>

- Возвращает:
  + max_rang(int)<br/><br/>

- Алгоритм:
  + Вход в цикл, проходящий по всем or-правилам
  + Инициализация списка `buf` = списку фактов из правила на данной итерации
  + Если ранг = 1, то запускается цикл по `buf`, в котором:
    + Проверяется наличие текущего элемента условной части в списке фактов бз
    + При совпадении всех элементов: `max_rang` = 2 (вложенность увеличилась на 1), добавление в `and_mass` словаря `{max_rang : новый факт из правила}`, добавление факта в `res, выход из цикла 
  + Иначе цикл по `and_mass`, где лежат словари типа {ранг: добавленный факт}:
    + Проверка на соответствие текущего ранга ключу словаря и на отсутствие факта текущего правила в `res` (смысла повторно добавлять нет)
    + В случае успешной проверки, вход в цикл по `buf`
      + Если факт из условной части не в бз, выход
    + В случае нормального завершения цикла добавление факта в `res`, увеличение `max_rang` на 1, добавление словаря в `and_mass`
  + `return max_rang` 
<br/><br/>

**Описание функции check_not:**
 + Вход в цикл, проходящий по всем not-правилам
   + Инициализация списка `buf` = списку фактов из правила на данной итерации
   + Вход в цикл по `buf`
     + Если какой-либо факт в бз, выход
   + В случае непринудительного выхода добавление факта в `res`

<br/><br/>
**Описание алгоритма main:**

1. Инициализация переменных:

    `res` - список размерностью с бз, индексы соответствуют фактам, значение = 1 если факт есть, иначе *None*<br/>
    `res_facts` - список всех существующих фактов<br/>
    `or_mass` - список фактов правил *or* со вложенностью > 1<br/>
    `and_mass` - список фактов правил *and* со вложенностью > 1<br/>
    `rang` - текущее значение вложенности (далее - ранга), изначально = 1<br/>
    `max_rang` - максимальное значение ранга, изначально = 1<br/><br/>

2. Вызов функции `neg_or_pos_rules` для разделения на 3 секции<br/><br/>
3. Вызов функции `controversy_not_a_b_not_b_a` для разрешения противоречий типа `'not(A) -> B & not(B) -> A'`. Достаточно вызвать 1 раз, так как затем факты лишь прибавляются, и новых противоречий данного типа не появится<br/><br/>
4. Вход в цикл while (условие - текущий ранг < максимального, так как за максимальным рангом новых фактов не будет, на то он и максимальный)<br/><br/>
4.1 Каждый раз увеличивается набор фактов, заново ищем противоречия типа `'not(A) -> B & not(B) -> A'` с помощью функции `controversy_ab_not_ab`<br/><br/>
4.2 Вызов функций `check_or`, `check_and`, каждая возвращает максимальный ранг каждая для своих правил, из них выбирается больший, который присваивается переменной `max_rang`<br/><br/>
4.3 Вызов функции `check_not`, появляются новые факты. За счет предварительной обработки новых противоречий не появляется<br/><br/>
4.4 Увеличение переменной `rang` на 1.<br/><br/>
4.5 Переход к 4.1 при соблюдении условий<br/><br/>
5. Вход в цикл while (условие - `index` < размера бз)<br/><br/>
5.1 Если переменная списка `res` `(res[index])` равна 1 - добавление в `res_facts` значения `index`<br/><br/>
5.2 `index` += 1<br/><br/>
6. `return res_facts`

<br/><br/>
**Результат**

Все факты (те, что имелись + новые) базы знаний

<br/><br/>
**Quick start**

*Построение docker-образа*

```
docker build -t generator:1.0 .
```

*Запуск docker-контейнера*

```
docker run generator:1.0
```

